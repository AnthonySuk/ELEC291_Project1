0000              1   ;2024/2/11 21:18
0000              2   ; N76E003 LCD_Pushbuttons.asm: Reads muxed push buttons using one input
0000              3   
                  5   $LIST
0000              7   
0000              8   ;  N76E003 pinout:
0000              9   ;                               -------
0000             10   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             11   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             12   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             13   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             14   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             15   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             16   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             17   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             18   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             19   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             20   ;                               -------
0000             21   ;
0000             22   
0000             23   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             24   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             25   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             27   
0000             28   
0000             29   
0000             30   TIMER2_RATE   EQU 1000     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             31   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             32   
0000             33   
0000             34   ;Tj_temp equ #0x25
0000             35   
0000             36   ORG 0x0000
0000 02086E      37            ljmp main
0003             38   
0003             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020417      41            ljmp Timer2_ISR
002E             42   
002E             43   ;---------------------------------;
002E             44   ;      String Declarations                 ;
002E             45   ;---------------------------------;
002E             46   ;              1234567890123456    <- This helps determine the location of the counter
002E             47   ;Line1:    db 'LCD PUSH BUTTONS' , 0
002E 546F3D20    48   Line1:     db 'To= xxC  Tj=xxC ' ,0
     78784320
     20546A3D
     78784320
     00
003F 53787878    49   Line2:     db 'Sxxx,xx  Rxxx,xx' ,0
     2C787820
     20527878
     782C7878
     00
0050 20202000    50   Blank_3:   db '   '                               ,0
0054 202000      51   Blank_2:   db '  '                                ,0
0057 5300        52   S:                  db 'S'                                ,0
0059 5200        53   R:                  db 'R'                                ,0
005B 53544F50    54   Reflow_n:  db 'STOP          ',0
     20202020
     20202020
     202000
006A 52414D50    55   Reflow_0:  db 'RAMP SOAK   ',0
     20534F41
     4B202020
     00
0077 534F414B    56   Reflow_1:  db 'SOAK        ',0
     20202020
     20202020
     00
0084 52414D50    57   Reflow_2:  db 'RAMP PEAK   ',0
     20504541
     4B202020
     00
0091 5245464C    58   Reflow_3:  db 'REFLOW      ',0
     4F572020
     20202020
     00
009E 434F4F4C    59   Reflow_4:  db 'COOLIG      ',0
     49472020
     20202020
     00
00AB 20202020    60   Blank:     db '                 ',0
     20202020
     20202020
     20202020
     2000
00BD 20546F20    61   Warning:   db ' To IS TOO LOW!  ',0
     49532054
     4F4F204C
     4F572120
     2000
00CF             62   
00CF             63   
00CF             64   ;---------------------------------;
00CF             65   ;        Pin Connections                   ;
00CF             66   ;---------------------------------;
00CF             67   cseg
00CF             68   ; These 'equ' must match the hardware wiring
00CF             69   ; change all p1.3 to p1.2
00CF             70   ; speaker pin15
00CF             71   ; LM335(detect temp) pin14
00CF             72   LCD_RS equ P1.2
00CF             73   LCD_E  equ P1.4
00CF             74   LCD_D4 equ P0.0
00CF             75   LCD_D5 equ P0.1
00CF             76   LCD_D6 equ P0.2
00CF             77   LCD_D7 equ P0.3
00CF             78   ; Button 
00CF             79   ; For some reason, we reverse the pin of increase and decrease
00CF             80   BUTTON_START    equ P1.2
00CF             81   BUTTON_STOP     equ P0.0
00CF             82   BUTTON_SELECT   equ P0.1
00CF             83   BUTTON_INCREASE equ P0.3
00CF             84   BUTTON_DECREASE equ P0.2
00CF             85   
00CF             86   ;declare the pin for speaker
00CF             87   SOUND_OUT equ P1.0
00CF             88   
00CF             89   ;declare the pin for PWM
00CF             90   PWM_OUT equ P1.6
00CF             91   
00CF             92   ;---------------------------------;
00CF             93   ;            Bit Segment                   ;
00CF             94   ;---------------------------------;
0000             95   BSEG
0000             96   PB_START   : dbit 1
0001             97   PB_STOP    : dbit 1
0002             98   PB_SELECT  : dbit 1
0003             99   PB_INCREASE: dbit 1
0004            100   PB_DECREASE: dbit 1
0005            101   mf: dbit 1
0006            102   checking_sound: dbit 1
0007            103   
0007            104   ;---------------------------------;
0007            105   ;          Data Segment                    ;
0007            106   ;---------------------------------;
0007            107   ; These register definitions needed by 'math32.inc'
0030            108   DSEG at 30H
0030            109   x:   ds 4
0034            110   y:   ds 4
0038            111   bcd: ds 5
003D            112   VLED_ADC: ds 2
003F            113   temp: ds 1
0040            114   
0050            115   DSEG at 0x50
0050            116   TIME_SOAK: ds 1
0051            117   TIME_REFLOW: ds 1
0052            118   TEMP_SOAK: ds 1
0053            119   TEMP_REFLOW: ds 1
0054            120   
0054            121   
0054            122   pwm: ds 1
0055            123   FSM1_state: ds 1
0056            124   sec: ds 1
0057            125   TIME_REALTIME: ds 1
0058            126   pwm_counter: ds 1
0059            127   
0059            128   ; Counter
0059            129   COUNTER_BUTTON_SELECT: ds 1
005A            130   COUNTER_TIME_PWM: ds 2
005C            131   Tj_temp: ds 1
005D            132   COUNTER_1MS: ds 2
005F            133   
005F            134   
005F            135   ;---------------------------------;
005F            136   ;          Include Segment                 ;
005F            137   ;---------------------------------;
                546   $LIST
                140   	$LIST
03F3            142   
03F3            143   ;---------------------------------;
03F3            144   ;          Code Segment                    ;
03F3            145   ;---------------------------------;
03F3            146   CSEG
03F3            147   ;Timer2 initialization
03F3            148   Timer2_Init:
03F3 75C800     149            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03F6 75CDBF     150            mov TH2, #high(TIMER2_RELOAD)
03F9 75CC28     151            mov TL2, #low(TIMER2_RELOAD)
03FC            152            ; Set the reload value
03FC 43C980     153            orl T2MOD, #0x80 ; Enable timer 2 autoreload
03FF 75CBBF     154            mov RCMP2H, #high(TIMER2_RELOAD)
0402 75CA28     155            mov RCMP2L, #low(TIMER2_RELOAD)
0405            156            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0405 E4         157            clr a
0406 F55D       158            mov COUNTER_1MS+0, a
0408 F55E       159            mov COUNTER_1MS+1, a
040A F55A       160            mov COUNTER_TIME_PWM+0, A
040C F55B       161            mov COUNTER_TIME_PWM+1, A
040E            162   
040E 755800     163            mov pwm_counter,#0
0411            164            ; Enable the timer and interrupts
0411 439B80     165            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0414 D2CA       166       setb TR2  ; Enable timer 2
0416 22         167            ret
0417            168   
0417            169   ;---------------------------------;
0417            170   ; ISR for timer 2                 ;
0417            171   ;---------------------------------;
0417            172   Timer2_ISR:
0417 C2CF       173            clr TF2
0419 C0E0       174            push acc
041B C0D0       175            push psw
041D            176   Timer2_ISR_Inc_COUTERPWM:
041D 055A       177            inc COUNTER_TIME_PWM+0
041F E55A       178            mov a, COUNTER_TIME_PWM+0
0421 7004       179            jnz Timer2_PWM_Inc_Done
0423 055B       180            inc COUNTER_TIME_PWM+1
0425 8021       181            sjmp Timer2_ISR_Inc_COUTER1MS
0427            182            
0427            183   Timer2_PWM_Inc_Done:
0427 E55A       184            mov a,COUNTER_TIME_PWM+0
0429 B40A1C     185            cjne a,#low(10), Timer2_ISR_Inc_COUTER1MS
042C E55B       186            mov a,COUNTER_TIME_PWM+1
042E B40017     187            cjne a,#high(10), Timer2_ISR_Inc_COUTER1MS
0431            188   
0431 E4         189            clr a
0432 F55A       190            mov COUNTER_TIME_PWM+0, a
0434 F55B       191            mov COUNTER_TIME_PWM+1, a
0436            192   
0436 0558       193            inc pwm_counter
0438 C3         194            clr c
0439 E554       195            mov a, pwm
043B 9558       196            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
043D B3         197            cpl c
043E 9296       198            mov PWM_OUT, c
0440            199            
0440 E558       200            mov a, pwm_counter
0442 B46403     201            cjne a, #100, Timer2_ISR_Inc_COUTER1MS
0445 755800     202            mov pwm_counter, #0     
0448            203   
0448            204   Timer2_ISR_Inc_COUTER1MS:
0448 055D       205       inc COUNTER_1MS+0
044A E55D       206            mov a, COUNTER_1MS+0
044C 7004       207            jnz Timer2_RealTime_Inc_Done
044E 055E       208            inc COUNTER_1MS+1
0450 8000       209            sjmp Timer2_RealTime_Inc_Done
0452            210            
0452            211   Timer2_RealTime_Inc_Done:
0452 E55D       212            mov a,COUNTER_1MS+0
0454 B4E81C     213            cjne a,#low(1000), Timer2_ISR_Done
0457 E55E       214            mov a,COUNTER_1MS+1
0459 B40317     215            cjne a,#high(1000), Timer2_ISR_Done
045C            216   
045C E55D       217            mov a,COUNTER_1MS+0
045E B4E812     218            cjne a,#low(1000), Timer2_ISR_Done
0461 E55E       219            mov a,COUNTER_1MS+1
0463 B4030D     220            cjne a,#high(1000), Timer2_ISR_Done
0466            221            ; 1 second is satisfy, clean counter
0466 E4         222            clr A
0467 F55D       223            mov COUNTER_1MS+0,A
0469 F55E       224            mov COUNTER_1MS+1,A
046B            225            ;add 1 to TIME_REALTIME
046B E557       226            mov a,TIME_REALTIME
046D 2401       227            add a,#1
046F F557       228            mov TIME_REALTIME,a
0471 0556       229            inc sec ; It is super easy to keep a seconds count here
0473            230   
0473            231   Timer2_ISR_Done:
0473 D0D0       232            pop psw
0475 D0E0       233            pop acc
0477 32         234            reti
0478            235   
0478            236   Init_All:
0478            237            ; Configure all the pins for biderectional I/O
0478 75AC00     238            mov     P3M1, #0x00
047B 75AD00     239            mov     P3M2, #0x00
047E 75B300     240            mov     P1M1, #0x00
0481 75B400     241            mov     P1M2, #0x00
0484 75B100     242            mov     P0M1, #0x00
0487 75B200     243            mov     P0M2, #0x00
048A            244   
048A            245   ;Timer0 initialization   
048A            246            ;Timer 0 using for delay functions
048A            247            ; Using timer 0 for delay functions.  Initialize here:
048A C28C       248            clr     TR0 ; Stop timer 0
048C 438E08     249            orl     CKCON,#0x08 ; CLK is the input for timer 0
048F 5389F0     250            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0492 438901     251            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0495            252   
0495            253            ;Timer 1 using for generate baud rate
0495 438E10     254            orl     CKCON, #0x10 ; CLK is the input for timer 1
0498 438780     255            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
049B 759852     256            mov     SCON, #0x52
049E 53C4DF     257            anl     T3CON, #0b11011111
04A1 53890F     258            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
04A4 438920     259            orl     TMOD, #0x20 ; Timer 1 Mode 2
04A7 758DF7     260            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
04AA D28E       261            setb TR1
04AC            262   ;Timer2 initialization
04AC            263   ;------------------------------------------;
04AC            264   ;Timer 2(for now speaker)
04AC 1203F3     265            lcall Timer2_Init 
04AF            266   ;------------------------------------------;
04AF            267   
04AF            268   ; Button Initial
04AF 755900     269            mov COUNTER_BUTTON_SELECT,#0x00
04B2 755296     270            mov TEMP_SOAK,#150
04B5 755010     271            mov TIME_SOAK,#0x10
04B8 7553C8     272            mov TEMP_REFLOW,#200
04BB 755110     273            mov TIME_REFLOW,#0x10
04BE            274   
04BE            275   ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
04BE 43B322     276            orl     P1M1, #0b00100010
04C1 53B4DD     277            anl     P1M2, #0b11011101
04C4            278            
04C4            279            ; Initialize and start the ADC:
04C4 53E8F0     280            anl ADCCON0, #0xF0
04C7 43E805     281            orl ADCCON0, #0x05 ; Select channel 7
04CA            282            ; AINDIDS select if some pins are analog inputs or digital I/O:
04CA 75F600     283            mov AINDIDS, #0x00 ; Disable all analog inputs
04CD 43F621     284            orl AINDIDS, #0b00100001 ; Activate AIN0 and AIN7 analog inputs
04D0 43E101     285            orl ADCCON1, #0x01 ; Enable ADC
04D3 D2AF       286            setb EA
04D5 22         287            ret
04D6            288   
04D6            289   ;delay configuration
04D6            290   wait_1ms:
04D6 C28C       291            clr     TR0 ; Stop timer 0
04D8 C28D       292            clr     TF0 ; Clear overflow flag
04DA 758CBF     293            mov     TH0, #high(TIMER0_RELOAD_1MS)
04DD 758A28     294            mov     TL0,#low(TIMER0_RELOAD_1MS)
04E0 D28C       295            setb TR0
04E2 308DFD     296            jnb     TF0, $ ; Wait for overflow
04E5 22         297            ret
04E6            298   
04E6            299   ; Wait the number of miliseconds in R2
04E6            300   waitms:
04E6 1204D6     301            lcall wait_1ms
04E9 DAFB       302            djnz R2, waitms
04EB 22         303            ret
04EC            304   
04EC            305   ;Increase time number when button pushed
04EC            306   CHECK_BUTTON_INCREASE_time:
04EC 200301     307                    jb PB_INCREASE, Inc_num
04EF 22         308                    ret
04F0            309            Inc_num:
04F0 2401       310                    add a, #0x01
04F2 22         311                    ret
04F3            312            
04F3            313   ;Decrease time number when button pushed
04F3            314   CHECK_BUTTON_DECREASE_time:
04F3 200401     315                    jb PB_DECREASE, Dec_num
04F6 22         316                    ret
04F7            317            Dec_num:
04F7 C3         318                    clr c
04F8 9401       319                    subb a, #0x01
04FA 22         320                    ret
04FB            321   
04FB            322   SendString:
04FB E4         323       clr A
04FC 93         324       movc A, @A+DPTR
04FD 6003       325       jz SendStringDone
04FF            326       ;lcall putchar
04FF A3         327       inc DPTR
0500 80F9       328       sjmp SendString
0502            329   SendStringDone:
0502 22         330       ret
0503            331            
0503            332   ;Increase temp number when button pushed
0503            333   CHECK_BUTTON_INCREASE:
0503 200301     334            jb PB_INCREASE, Inc_temp_num
0506 22         335            ret
0507            336   Inc_temp_num:
0507 2401       337            add a, #0x01
0509 22         338            ret
050A            339            
050A            340   ;Decrease temp number when button pushed
050A            341   CHECK_BUTTON_DECREASE:
050A 200401     342            jb PB_DECREASE, Dec_temp_num
050D 22         343            ret
050E            344   Dec_temp_num:
050E C3         345            clr c
050F 9401       346            subb a, #0x01
0511 22         347            ret
0512            348   
0512            349   ;check state for choosing which number should be changed
0512            350   ; #0 default #1 S_temp #2 S_time #3 R_temp #4 R_time
0512            351   CHECK_BUTTON_SELECT_STATE:
0512 E559       352                    mov a, COUNTER_BUTTON_SELECT
0514            353            CHEKC_BUTTON_SELECT_STATE0:
0514 B40016     354                    cjne a, #0, CHECK_BUTTON_SELECT_STATE1
0517            355   
0517 C0E0       356            push acc
0519 740E       356            mov a, #14
051B 14         356            dec a
051C 1203D6     356            lcall ?Set_Cursor_2 ; Select column and row
051F D0E0       356            pop acc
0521 C0E0       357            push acc
0523 742C       357            mov a, #','
0525 12038E     357            lcall ?WriteData
0528 D0E0       357            pop acc
052A            358   
052A 0205D0     359                    ljmp CHECK_BUTTON_SELECT_STATE_DONE
052D            360            CHECK_BUTTON_SELECT_STATE1:
052D C0E0       361            push acc
052F 7401       361            mov a, #1
0531 14         361            dec a
0532 1203D6     361            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       361            pop acc
0537            362   
0537 B40116     363                    cjne a, #1, CHECK_BUTTON_SELECT_STATE2
053A E552       364                    mov a,TEMP_SOAK
053C 120503     365                    lcall CHECK_BUTTON_INCREASE
053F 12050A     366                    lcall CHECK_BUTTON_DECREASE
0542 F552       367                    mov TEMP_SOAK, a
0544            368   
0544 C0E0       369            push acc
0546 743D       369            mov a, #'='
0548 12038E     369            lcall ?WriteData
054B D0E0       369            pop acc
054D            370   
054D 0205D0     371                    ljmp CHECK_BUTTON_SELECT_STATE_DONE
0550            372            CHECK_BUTTON_SELECT_STATE2:
0550 C0E0       373            push acc
0552 7452       373            mov a, #'R'
0554 12038E     373            lcall ?WriteData
0557 D0E0       373            pop acc
0559 C0E0       374            push acc
055B 7405       374            mov a, #5
055D 14         374            dec a
055E 1203D6     374            lcall ?Set_Cursor_2 ; Select column and row
0561 D0E0       374            pop acc
0563            375   
0563 B40216     376                    cjne a,#2,CHECK_BUTTON_SELECT_STATE3
0566 E550       377                    mov a,TIME_SOAK
0568 1204EC     378                    lcall CHECK_BUTTON_INCREASE_time
056B 1204F3     379                    lcall CHECK_BUTTON_DECREASE_time
056E F550       380                    mov TIME_SOAK, a
0570            381   
0570 C0E0       382            push acc
0572 743D       382            mov a, #'='
0574 12038E     382            lcall ?WriteData
0577 D0E0       382            pop acc
0579            383   
0579 0205D0     384                    ljmp CHECK_BUTTON_SELECT_STATE_DONE
057C            385            CHECK_BUTTON_SELECT_STATE3:
057C C0E0       386            push acc
057E 742C       386            mov a, #','
0580 12038E     386            lcall ?WriteData
0583 D0E0       386            pop acc
0585 C0E0       387            push acc
0587 740A       387            mov a, #10
0589 14         387            dec a
058A 1203D6     387            lcall ?Set_Cursor_2 ; Select column and row
058D D0E0       387            pop acc
058F            388   
058F B40315     389                    cjne a,#3,CHECK_BUTTON_SELECT_STATE4
0592 E553       390                    mov a,TEMP_REFLOW
0594 120503     391                    lcall CHECK_BUTTON_INCREASE
0597 12050A     392                    lcall CHECK_BUTTON_DECREASE
059A F553       393                    mov TEMP_REFLOW, a
059C            394                    
059C C0E0       395            push acc
059E 743D       395            mov a, #'='
05A0 12038E     395            lcall ?WriteData
05A3 D0E0       395            pop acc
05A5            396   
05A5 8029       397                    sjmp CHECK_BUTTON_SELECT_STATE_DONE
05A7            398            CHECK_BUTTON_SELECT_STATE4:
05A7 C0E0       399            push acc
05A9 7453       399            mov a, #'S'
05AB 12038E     399            lcall ?WriteData
05AE D0E0       399            pop acc
05B0 C0E0       400            push acc
05B2 740E       400            mov a, #14
05B4 14         400            dec a
05B5 1203D6     400            lcall ?Set_Cursor_2 ; Select column and row
05B8 D0E0       400            pop acc
05BA            401   
05BA B40413     402                    cjne a,#4,CHECK_BUTTON_SELECT_STATE_DONE
05BD E551       403                    mov a,TIME_REFLOW
05BF 1204EC     404                    lcall CHECK_BUTTON_INCREASE_time
05C2 1204F3     405                    lcall CHECK_BUTTON_DECREASE_time
05C5 F551       406                    mov TIME_REFLOW, a
05C7            407                    
05C7 C0E0       408            push acc
05C9 743D       408            mov a, #'='
05CB 12038E     408            lcall ?WriteData
05CE D0E0       408            pop acc
05D0            409            CHECK_BUTTON_SELECT_STATE_DONE:
05D0 22         410                    ret     
05D1            411   
05D1            412   
05D1            413   
05D1            414   ;Detect which botton is pushed
05D1            415   LCD_PB:
05D1            416                    ; Set variables to 1: 'no push button pressed'
05D1 D200       417                    setb PB_START
05D3 D201       418                    setb PB_STOP
05D5 D202       419                    setb PB_SELECT
05D7 D203       420                    setb PB_INCREASE
05D9 D204       421                    setb PB_DECREASE
05DB            422                    ; The input pin used to check set to '1'
05DB D295       423                    setb P1.5
05DD            424                    ; Check if any push button is pressed
05DD            425                    ; When all button not press, positive will connect with P1.5 and pull P1.5 up, P1.5 will not be zero
05DD C292       426                    clr BUTTON_START
05DF C280       427                    clr BUTTON_STOP
05E1 C281       428                    clr BUTTON_SELECT
05E3 C283       429                    clr BUTTON_INCREASE
05E5 C282       430                    clr BUTTON_DECREASE
05E7 209543     431                    jb P1.5, LCD_PB_Done
05EA            432                    ; Debounce
05EA 7A0A       433                    mov R2, #10
05EC 12085B     434                    lcall Waitms_NOINT
05EF 20953B     435                    jb P1.5, LCD_PB_Done
05F2            436                    ; Set the LCD data pins to logic 1
05F2 D292       437                    setb BUTTON_START
05F4 D280       438                    setb BUTTON_STOP
05F6 D281       439                    setb BUTTON_SELECT
05F8 D283       440                    setb BUTTON_INCREASE
05FA D282       441                    setb BUTTON_DECREASE
05FC            442                    ; Check the push buttons one by one
05FC C292       443                    clr BUTTON_START
05FE A295       444                    mov c, P1.5
0600 9200       445                    mov PB_START, c
0602 D292       446                    setb BUTTON_START
0604            447            
0604 C280       448                    clr BUTTON_STOP
0606 A295       449                    mov c, P1.5
0608 9201       450                    mov PB_STOP, c
060A D280       451                    setb BUTTON_STOP
060C            452   
060C C281       453                    clr BUTTON_SELECT
060E A295       454                    mov c, P1.5
0610 9202       455                    mov PB_SELECT, c
0612 D281       456                    setb BUTTON_SELECT
0614            457   
0614 C283       458                    clr BUTTON_INCREASE
0616 A295       459                    mov c, P1.5
0618 9203       460                    mov PB_INCREASE, c
061A D283       461                    setb BUTTON_INCREASE
061C            462   
061C C282       463                    clr BUTTON_DECREASE
061E A295       464                    mov c, P1.5
0620 9204       465                    mov PB_DECREASE, c
0622 D282       466                    setb BUTTON_DECREASE
0624            467                    ; Call function
0624 300007     468                    jnb PB_START, CHECK_BUTTON_START
0627 300110     469                    jnb PB_STOP , CHECK_BUTTON_STOP
062A 300216     470                    jnb PB_SELECT, CHECK_BUTTON_SELECT
062D            471            LCD_PB_Done:            
062D 22         472                    ret
062E            473   
062E            474   ;FSM start
062E            475   CHECK_BUTTON_START:
062E C0E0       476            push acc
0630            477            ;setb TR2
0630 7401       478            mov a, #0x01
0632 F555       479            mov FSM1_state, a
0634 755700     480            mov TIME_REALTIME, #0
0637 D0E0       481            pop acc
0639 22         482            ret
063A            483   
063A            484   ;FSM stop
063A            485   CHECK_BUTTON_STOP:
063A C0E0       486            push acc
063C            487            
063C 7400       488            mov a, #0x00
063E F555       489            mov FSM1_state, a
0640 D0E0       490            pop acc
0642 22         491            ret     
0643            492   
0643            493   ;Check whcih variable should be changed
0643            494   CHECK_BUTTON_SELECT:
0643 E559       495                    mov a,COUNTER_BUTTON_SELECT
0645 2401       496                    add a, #1
0647 D4         497                    da a
0648 B40505     498                    cjne a,#5,Not_reset
064B 755900     499                    mov COUNTER_BUTTON_SELECT,#0
064E 8004       500                    sjmp CHECK_BUTTON_SELECT_DONE
0650            501            Not_reset:
0650 F559       502                    mov COUNTER_BUTTON_SELECT,a
0652 E4         503                    clr a
0653 22         504                    ret
0654            505            CHECK_BUTTON_SELECT_DONE:
0654 22         506                    ret
0655            507   
0655            508   ;Display information on LCD
0655            509   Display_PushButtons_LCD:
0655 C0E0       510            push acc
0657 7402       510            mov a, #2
0659 14         510            dec a
065A 1203D6     510            lcall ?Set_Cursor_2 ; Select column and row
065D D0E0       510            pop acc
065F E552       511            mov a, TEMP_SOAK
0661 12079E     512            lcall SendToLCD
0664            513            
0664 C0E0       514            push acc
0666 7406       514            mov a, #6
0668 14         514            dec a
0669 1203D6     514            lcall ?Set_Cursor_2 ; Select column and row
066C D0E0       514            pop acc
066E E550       515            mov a, TIME_SOAK
0670 1207BA     516            lcall SendToLCD_2digit
0673            517            
0673            518            ;Test Only, show COUNTER_BUTTON_SELECT
0673 C0E0       519            push acc
0675 7408       519            mov a, #8
0677 14         519            dec a
0678 1203D6     519            lcall ?Set_Cursor_2 ; Select column and row
067B D0E0       519            pop acc
067D E558       520            mov a,pwm_counter
067F            521            ;Display_BCD(COUNTER_BUTTON_SELECT)
067F 12079E     522            lcall SendToLCD
0682            523            
0682 C0E0       524            push acc
0684 740B       524            mov a, #11
0686 14         524            dec a
0687 1203D6     524            lcall ?Set_Cursor_2 ; Select column and row
068A D0E0       524            pop acc
068C E553       525            mov a, TEMP_REFLOW
068E 12079E     526            lcall SendToLCD
0691            527                    
0691 C0E0       528            push acc
0693 740F       528            mov a, #15
0695 14         528            dec a
0696 1203D6     528            lcall ?Set_Cursor_2 ; Select column and row
0699 D0E0       528            pop acc
069B E551       529            mov a, TIME_REFLOW
069D 1207BA     530            lcall SendToLCD_2digit
06A0 22         531            ret     
06A1            532            
06A1            533   ; Display the room temperature in LCD
06A1            534   Display_Tj_ban:
06A1 C2EF       535            clr ADCF
06A3 D2EE       536            setb ADCS ;  ADC start trigger signal
06A5 30EFFD     537       jnb ADCF, $ ; for conversion complete
06A8            538       
06A8            539       ; Read the ADC result and store in [R1, R0]
06A8 C0E0       540       push acc
06AA E5C3       541       mov a, ADCRH   
06AC C4         542       swap a
06AD C0E0       543       push acc
06AF 540F       544       anl a, #0x0f
06B1 F9         545       mov R1, a
06B2 D0E0       546       pop acc
06B4 54F0       547       anl a, #0xf0
06B6 45C2       548       orl a, ADCRL
06B8 F8         549       mov R0, A
06B9            550       
06B9            551       ; Convert to voltage
06B9 8830       552            mov x+0, R0
06BB 8931       553            mov x+1, R1
06BD 753200     554            mov x+2, #0
06C0 753300     555            mov x+3, #0
06C3 75345C     556            mov y+0, #low (49500 % 0x10000) 
06C6 7535C1     556            mov y+1, #high(49500 % 0x10000) 
06C9 753600     556            mov y+2, #low (49500 / 0x10000) 
06CC 753700     556            mov y+3, #high(49500 / 0x10000)  ; VCC voltage measured
06CF 120249     557            lcall mul32
06D2 7534FF     558            mov y+0, #low (4095 % 0x10000) 
06D5 75350F     558            mov y+1, #high(4095 % 0x10000) 
06D8 753600     558            mov y+2, #low (4095 / 0x10000) 
06DB 753700     558            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
06DE 1202D6     559            lcall div32
06E1            560   
06E1            561            ;(vout-2.73)*100=vout*100-273
06E1 7534A4     562            mov y+0, #low (27300 % 0x10000) 
06E4 75356A     562            mov y+1, #high(27300 % 0x10000) 
06E7 753600     562            mov y+2, #low (27300 / 0x10000) 
06EA 753700     562            mov y+3, #high(27300 / 0x10000) 
06ED 1201B5     563            lcall sub32
06F0 753464     564            mov y+0, #low (100 % 0x10000) 
06F3 753500     564            mov y+1, #high(100 % 0x10000) 
06F6 753600     564            mov y+2, #low (100 / 0x10000) 
06F9 753700     564            mov y+3, #high(100 / 0x10000) 
06FC 120249     565            lcall mul32
06FF            566            
06FF            567            ; Convert to BCD and display
06FF 1200CF     568            lcall hex2bcd
0702            569            
0702 C0E0       570            push acc
0704 740D       570            mov a, #13
0706 14         570            dec a
0707 1203D8     570            lcall ?Set_Cursor_1 ; Select column and row
070A D0E0       570            pop acc
070C 120712     571            lcall Display_formated_BCD_Su ;give temperature to LCD
070F D0E0       572            pop acc
0711 22         573            ret
0712            574   
0712            575   Display_formated_BCD_Su:
0712 C000       576            push ar0
0714 A83A       576            mov r0, bcd+2
0716 1203DD     576            lcall ?Display_BCD
0719 D000       576            pop ar0
071B C0E0       577            push acc
071D 742E       577            mov a, #'.'
071F 12038E     577            lcall ?WriteData
0722 D0E0       577            pop acc
0724 C000       578            push ar0
0726 A839       578            mov r0, bcd+1
0728 1203DD     578            lcall ?Display_BCD
072B D000       578            pop ar0
072D C000       579            push ar0
072F A838       579            mov r0, bcd+0
0731 1203DD     579            lcall ?Display_BCD
0734 D000       579            pop ar0
0736 22         580            ret
0737            581   
0737            582   Display_Tj:
0737 C0E0       583            push acc
0739 740D       583            mov a, #13
073B 14         583            dec a
073C 1203D8     583            lcall ?Set_Cursor_1 ; Select column and row
073F D0E0       583            pop acc
0741 C0E0       584            push acc
0743 7432       584            mov a, #'2'
0745 12038E     584            lcall ?WriteData
0748 D0E0       584            pop acc
074A C0E0       585            push acc
074C 7432       585            mov a, #'2'
074E 12038E     585            lcall ?WriteData
0751 D0E0       585            pop acc
0753            586   
0753            587   Read_ADC:
0753 C2EF       588            clr ADCF
0755 D2EE       589            setb ADCS ;  ADC start trigger signal
0757 30EFFD     590       jnb ADCF, $ ; Wait for conversion complete
075A            591       
075A            592       ; Read the ADC result and store in [R1, R0]
075A E5C2       593       mov a, ADCRL
075C 540F       594       anl a, #0x0f
075E F8         595       mov R0, a
075F E5C3       596       mov a, ADCRH   
0761 C4         597       swap a
0762 C0E0       598       push acc
0764 540F       599       anl a, #0x0f
0766 F9         600       mov R1, a
0767 D0E0       601       pop acc
0769 54F0       602       anl a, #0xf0
076B 48         603       orl a, R0
076C F8         604       mov R0, A
076D 22         605            ret
076E            606   
076E            607   ;ADC USING, function for operating ADC
076E            608   Average_ADC:
076E 753000     609            mov x+0, #low (0 % 0x10000) 
0771 753100     609            mov x+1, #high(0 % 0x10000) 
0774 753200     609            mov x+2, #low (0 / 0x10000) 
0777 753300     609            mov x+3, #high(0 / 0x10000) 
077A 7DC8       610            mov R5, #200
077C            611   Sum_loop0:
077C 120753     612            lcall Read_ADC
077F 753700     613            mov y+3, #0
0782 753600     614            mov y+2, #0
0785 8935       615            mov y+1, R1
0787 8834       616            mov y+0, R0
0789 120194     617            lcall add32
078C DDEE       618            djnz R5, Sum_loop0
078E 7534C8     619            mov y+0, #low (200 % 0x10000) 
0791 753500     619            mov y+1, #high(200 % 0x10000) 
0794 753600     619            mov y+2, #low (200 / 0x10000) 
0797 753700     619            mov y+3, #high(200 / 0x10000) 
079A 1202D6     620            lcall div32
079D 22         621            ret
079E            622            
079E            623   ; Eight bit number to display passed in.
079E            624   ; Sends result to LCD
079E            625   SendToLCD:
079E 75F064     626            mov b, #100
07A1 84         627            div ab
07A2 4430       628            orl a, #0x30 ; Convert hundreds to ASCII
07A4 12038E     629            lcall ?WriteData ; Send to LCD
07A7 E5F0       630            mov a, b ; Remainder is in register b
07A9 75F00A     631            mov b, #10
07AC 84         632            div ab
07AD 4430       633            orl a, #0x30 ; Convert tens to ASCII
07AF 12038E     634            lcall ?WriteData; Send to LCD
07B2 E5F0       635            mov a, b
07B4 4430       636            orl a, #0x30 ; Convert units to ASCII
07B6 12038E     637            lcall ?WriteData; Send to LCD
07B9 22         638            ret
07BA            639            
07BA            640   SendToLCD_2digit:
07BA 75F00A     641            mov b, #10
07BD 84         642            div ab
07BE 4430       643            orl a, #0x30 ; Convert tens to ASCII
07C0 12038E     644            lcall ?WriteData; Send to LCD
07C3 E5F0       645            mov a, b
07C5 4430       646            orl a, #0x30 ; Convert units to ASCII
07C7 12038E     647            lcall ?WriteData; Send to LCD
07CA 22         648            ret
07CB            649            
07CB            650   Display_formated_BCD_Ste:
07CB E53F       651            mov a, temp
07CD C0E0       652            push acc
07CF 7404       652            mov a, #4
07D1 14         652            dec a
07D2 1203D8     652            lcall ?Set_Cursor_1 ; Select column and row
07D5 D0E0       652            pop acc
07D7 12079E     653            lcall SendToLCD
07DA 22         654            ret
07DB            655   
07DB            656   return:
07DB 0D0A00     657       DB  '\r', '\n', 0
07DE            658   
07DE            659   Send_to_computer:
07DE            660            ;push AR0
07DE            661            ;Send_BCD(bcd+1)
07DE            662       ;Send_BCD(bcd+0)
07DE            663       ;mov DPTR, #return
07DE            664       ;lcall SendString
07DE            665       ;pop AR0
07DE            666       ;ret
07DE            667   
07DE            668   Get_temp_adc:
07DE            669   ; Read the 2.08V LED voltage connected to AIN0 on pin 6
07DE 53E8F0     670            anl ADCCON0, #0xF0
07E1 43E800     671            orl ADCCON0, #0x00 ; Select channel 0
07E4 120753     672            lcall Read_ADC
07E7            673            ; Save result for later use
07E7 883D       674            mov VLED_ADC+0, R0
07E9 893E       675            mov VLED_ADC+1, R1
07EB            676   
07EB            677            ; Read the signal connected to AIN7
07EB 53E8F0     678            anl ADCCON0, #0xF0
07EE 43E805     679            orl ADCCON0, #0x05 ; Select channel 7
07F1            680            
07F1 12076E     681            lcall Average_ADC
07F4            682       
07F4            683       ; Convert to voltage
07F4 8830       684            mov x+0, R0
07F6 8931       685            mov x+1, R1
07F8            686            ; Pad other bits with zero
07F8 753200     687            mov x+2, #0
07FB 753300     688            mov x+3, #0
07FE 7534DC     689            mov y+0, #low (41180 % 0x10000) 
0801 7535A0     689            mov y+1, #high(41180 % 0x10000) 
0804 753600     689            mov y+2, #low (41180 / 0x10000) 
0807 753700     689            mov y+3, #high(41180 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
080A 120249     690            lcall mul32
080D            691            ; Retrive the ADC LED value
080D 853D34     692            mov y+0, VLED_ADC+0
0810 853E35     693            mov y+1, VLED_ADC+1
0813            694            ; Pad other bits with zero
0813 753600     695            mov y+2, #0
0816 753700     696            mov y+3, #0
0819 1202D6     697            lcall div32
081C            698            
081C 753403     699            mov y+0, #low (3 % 0x10000) 
081F 753500     699            mov y+1, #high(3 % 0x10000) 
0822 753600     699            mov y+2, #low (3 / 0x10000) 
0825 753700     699            mov y+3, #high(3 / 0x10000) 
0828 1202D6     700            lcall div32
082B 753429     701            mov y+0, #low (41 % 0x10000) 
082E 753500     701            mov y+1, #high(41 % 0x10000) 
0831 753600     701            mov y+2, #low (41 / 0x10000) 
0834 753700     701            mov y+3, #high(41 / 0x10000) 
0837 1202D6     702            lcall div32
083A 753416     703            mov y+0, #low (22 % 0x10000) 
083D 753500     703            mov y+1, #high(22 % 0x10000) 
0840 753600     703            mov y+2, #low (22 / 0x10000) 
0843 753700     703            mov y+3, #high(22 / 0x10000) 
0846 120194     704            lcall add32
0849            705   
0849 85303F     706            mov temp,x
084C            707   
084C            708            ; Convert to BCD and display
084C 1200CF     709            lcall hex2bcd
084F 1207CB     710            lcall Display_formated_BCD_Ste
0852            711            ; Wait 500 ms between conversions
0852 7A32       712            mov R2, #50
0854 12085B     713            lcall Waitms_NOINT
0857 1207DE     714            lcall Send_to_computer
085A 22         715            ret
085B            716   
085B            717   Waitms_NOINT:
085B C001       718            push AR1
085D C000       719            push AR0
085F 79C8       720   L3_1: mov R1, #200
0861 7868       721   L2_1: mov R0, #104
0863 D8FE       722   L1_1: djnz R0, L1_1 ; 4 cycles->4*60.24ns*104=25us
0865 D9FA       723       djnz R1, L2_1 ; 25us*200=5.0ms
0867 DAF6       724       djnz R2, L3_1 ; 5.0ms*100=0.5s (approximately)
0869 D000       725       pop AR0
086B D001       726       pop AR1
086D 22         727       ret
086E            728   
086E            729   ;---------------------------------;
086E            730   ;    main function starts here    ;
086E            731   ;---------------------------------;
086E            732   main:
086E 75817F     733            mov sp, #0x7f
0871 120478     734            lcall Init_All
0874 120398     735       lcall LCD_4BIT
0877            736       
0877            737       ; initial messages in LCD
0877 C0E0       738            push acc
0879 7401       738            mov a, #1
087B 14         738            dec a
087C 1203D8     738            lcall ?Set_Cursor_1 ; Select column and row
087F D0E0       738            pop acc
0881 C083       739            push dph
0883 C082       739            push dpl
0885 C0E0       739            push acc
0887 90002E     739            mov dptr, #Line1
088A 1203CB     739            lcall ?Send_Constant_String
088D D0E0       739            pop acc
088F D082       739            pop dpl
0891 D083       739            pop dph
0893            740   
0893            741            
0893 120737     742            lcall Display_Tj
0896 C0E0       743            push acc
0898 7401       743            mov a, #1
089A 14         743            dec a
089B 1203D6     743            lcall ?Set_Cursor_2 ; Select column and row
089E D0E0       743            pop acc
08A0 C083       744            push dph
08A2 C082       744            push dpl
08A4 C0E0       744            push acc
08A6 90003F     744            mov dptr, #Line2
08A9 1203CB     744            lcall ?Send_Constant_String
08AC D0E0       744            pop acc
08AE D082       744            pop dpl
08B0 D083       744            pop dph
08B2            745       
08B2 755500     746            mov FSM1_state, #0x00
08B5            747   
08B5            748            loop:
08B5 755400     749                    mov pwm,#0
08B8            750                    
08B8 120655     751                    lcall Display_PushButtons_LCD
08BB 80F8       752                    sjmp loop
08BD            753            
08BD            754   
08BD            755            FSM1:
08BD            756            
08BD            757            FSM1_state0:
08BD 1207DE     758            lcall Get_temp_adc
08C0 120737     759            lcall Display_Tj
08C3 120512     760            lcall CHECK_BUTTON_SELECT_STATE
08C6            761   
08C6 E555       762       mov a, FSM1_state
08C8 B4000C     763            cjne a, #0x00, FSM1_state1
08CB 1205D1     764            lcall LCD_PB
08CE 120655     765            lcall Display_PushButtons_LCD
08D1            766            
08D1 755600     767            mov sec,#0x00
08D4            768   
08D4            769   FSM1_state0_done:
08D4 0208BD     770       ljmp FSM1
08D7            771   FSM1_state1:
08D7            772            ;lcall Get_temp_adc
08D7            773            ;lcall Display_Tj
08D7 C0E0       774            push acc
08D9 740D       774            mov a, #13
08DB 14         774            dec a
08DC 1203D6     774            lcall ?Set_Cursor_2 ; Select column and row
08DF D0E0       774            pop acc
08E1 E557       775       mov a, TIME_REALTIME
08E3 12079E     776       lcall SendToLCD
08E6 C0E0       777            push acc
08E8 7473       777            mov a, #'s'
08EA 12038E     777            lcall ?WriteData
08ED D0E0       777            pop acc
08EF E555       778            mov a, FSM1_state
08F1 B4013A     779            cjne a, #1, ZHONGZHUAN
08F4 C0E0       780            push acc
08F6 7401       780            mov a, #1
08F8 14         780            dec a
08F9 1203D6     780            lcall ?Set_Cursor_2 ; Select column and row
08FC D0E0       780            pop acc
08FE C083       781            push dph
0900 C082       781            push dpl
0902 C0E0       781            push acc
0904 90006A     781            mov dptr, #Reflow_0
0907 1203CB     781            lcall ?Send_Constant_String
090A D0E0       781            pop acc
090C D082       781            pop dpl
090E D083       781            pop dph
0910 1205D1     782            lcall LCD_PB
0913 755432     783            mov pwm, #50
0916 E557       784            mov a, TIME_REALTIME
0918 C3         785            clr c
0919 B43C00     786            cjne a, #60, next_check
091C            787   next_check:
091C 5013       788            jnc check_abort 
091E            789   Continue_state1:
091E E552       790            mov a, TEMP_SOAK
0920 C3         791            clr c
0921 953F       792            subb a, temp
0923 5006       793            jnc FSM1_state1_done
0925 755502     794            mov FSM1_state, #2
0928 755600     795            mov sec, #0
092B            796   FSM1_state1_done:
092B 0208BD     797            ljmp FSM1
092E            798            
092E            799   ZHONGZHUAN:
092E 020981     800            ljmp FSM1_state2
0931            801            
0931            802   check_abort:
0931 C3         803            clr c
0932 F53F       804            mov temp, a
0934 9432       805            subb a, #50
0936 4003       806            jc ABORTION
0938 02091E     807            ljmp Continue_state1
093B            808   ABORTION:
093B 755500     809            mov FSM1_state,#0
093E C0E0       810            push acc
0940 7401       810            mov a, #1
0942 14         810            dec a
0943 1203D6     810            lcall ?Set_Cursor_2 ; Select column and row
0946 D0E0       810            pop acc
0948 C083       811            push dph
094A C082       811            push dpl
094C C0E0       811            push acc
094E 9000BD     811            mov dptr, #Warning
0951 1203CB     811            lcall ?Send_Constant_String
0954 D0E0       811            pop acc
0956 D082       811            pop dpl
0958 D083       811            pop dph
095A 7AC8       812       mov R2, #200
095C 12085B     813       lcall Waitms_NOINT
095F 12085B     814       lcall Waitms_NOINT
0962 C0E0       815            push acc
0964 7401       815            mov a, #1
0966 14         815            dec a
0967 1203D6     815            lcall ?Set_Cursor_2 ; Select column and row
096A D0E0       815            pop acc
096C C083       816            push dph
096E C082       816            push dpl
0970 C0E0       816            push acc
0972 90003F     816            mov dptr, #Line2
0975 1203CB     816            lcall ?Send_Constant_String
0978 D0E0       816            pop acc
097A D082       816            pop dpl
097C D083       816            pop dph
097E 0208BD     817            ljmp FSM1
0981            818   ;;wait soak
0981            819   FSM1_state2:
0981            820            ;lcall Get_temp_adc
0981            821            ;lcall Display_Tj
0981 E555       822            mov a, FSM1_state
0983 B4022F     823            cjne a, #2, FSM1_state3
0986 C0E0       824            push acc
0988 7401       824            mov a, #1
098A 14         824            dec a
098B 1203D6     824            lcall ?Set_Cursor_2 ; Select column and row
098E D0E0       824            pop acc
0990 C083       825            push dph
0992 C082       825            push dpl
0994 C0E0       825            push acc
0996 900077     825            mov dptr, #Reflow_1
0999 1203CB     825            lcall ?Send_Constant_String
099C D0E0       825            pop acc
099E D082       825            pop dpl
09A0 D083       825            pop dph
09A2 1205D1     826            lcall LCD_PB
09A5            827   next_2:
09A5            828   
09A5 755414     829       mov pwm, #20
09A8 E550       830       mov a, TIME_SOAK
09AA C3         831       clr c
09AB 9556       832       subb a, sec
09AD 5003       833       jnc FSM1_state2_done
09AF 755503     834       mov FSM1_state, #3
09B2            835   FSM1_state2_done:
09B2 0208BD     836       ljmp FSM1
09B5            837   ;;wait until temp reflow
09B5            838   FSM1_state3:
09B5            839            ;lcall Get_temp_adc
09B5            840            ;lcall Display_Tj
09B5 E555       841            mov a, FSM1_state
09B7 B40332     842            cjne a, #3, FSM1_state4
09BA C0E0       843            push acc
09BC 7401       843            mov a, #1
09BE 14         843            dec a
09BF 1203D6     843            lcall ?Set_Cursor_2 ; Select column and row
09C2 D0E0       843            pop acc
09C4 C083       844            push dph
09C6 C082       844            push dpl
09C8 C0E0       844            push acc
09CA 900084     844            mov dptr, #Reflow_2
09CD 1203CB     844            lcall ?Send_Constant_String
09D0 D0E0       844            pop acc
09D2 D082       844            pop dpl
09D4 D083       844            pop dph
09D6 1205D1     845            lcall LCD_PB
09D9            846   next_3:
09D9 755464     847            mov pwm, #100
09DC E553       848            mov a,TEMP_REFLOW
09DE C3         849            clr c
09DF 953F       850            subb a,temp
09E1 5006       851            jnc FSM1_state3_done
09E3 755504     852            mov FSM1_state,#4
09E6 755600     853            mov sec,#0
09E9            854            
09E9            855   FSM1_state3_done:
09E9 0208BD     856            ljmp FSM1
09EC            857   
09EC            858   FSM1_state4:
09EC            859            ;lcall Get_temp_adc
09EC            860            ;lcall Display_Tj
09EC E555       861            mov a, FSM1_state
09EE B40432     862            cjne a, #4, FSM1_state5
09F1 C0E0       863            push acc
09F3 7401       863            mov a, #1
09F5 14         863            dec a
09F6 1203D6     863            lcall ?Set_Cursor_2 ; Select column and row
09F9 D0E0       863            pop acc
09FB C083       864            push dph
09FD C082       864            push dpl
09FF C0E0       864            push acc
0A01 900091     864            mov dptr, #Reflow_3
0A04 1203CB     864            lcall ?Send_Constant_String
0A07 D0E0       864            pop acc
0A09 D082       864            pop dpl
0A0B D083       864            pop dph
0A0D 1205D1     865            lcall LCD_PB
0A10            866   next_4:
0A10 755414     867            mov pwm,#20
0A13 E551       868            mov a,TIME_REFLOW
0A15 C3         869            clr c
0A16 9556       870            subb a,sec      
0A18 5006       871            jnc FSM1_state4_done
0A1A 755505     872            mov FSM1_state,#5
0A1D 755600     873            mov sec,#0x00
0A20            874   FSM1_state4_done:
0A20 0208BD     875            ljmp FSM1
0A23            876   
0A23            877   FSM1_state5:
0A23 1207DE     878            lcall Get_temp_adc
0A26 120737     879            lcall Display_Tj
0A29 C0E0       880            push acc
0A2B 7401       880            mov a, #1
0A2D 14         880            dec a
0A2E 1203D6     880            lcall ?Set_Cursor_2 ; Select column and row
0A31 D0E0       880            pop acc
0A33 C083       881            push dph
0A35 C082       881            push dpl
0A37 C0E0       881            push acc
0A39 90009E     881            mov dptr, #Reflow_4
0A3C 1203CB     881            lcall ?Send_Constant_String
0A3F D0E0       881            pop acc
0A41 D082       881            pop dpl
0A43 D083       881            pop dph 
0A45            882            ;cjne a, #5,FSM1_state0
0A45 1205D1     883            lcall LCD_PB
0A48 755400     884            mov pwm,#0
0A4B 7460       885            mov a,#0x60
0A4D C3         886            clr c
0A4E 953F       887            subb a,temp
0A50 403E       888            jc FSM1_state5_done
0A52 755500     889            mov FSM1_state,#0
0A55 755600     890            mov sec,#0x00
0A58 C0E0       891            push acc
0A5A 7401       891            mov a, #1
0A5C 14         891            dec a
0A5D 1203D6     891            lcall ?Set_Cursor_2 ; Select column and row
0A60 D0E0       891            pop acc
0A62 C083       892            push dph
0A64 C082       892            push dpl
0A66 C0E0       892            push acc
0A68 9000AB     892            mov dptr, #Blank
0A6B 1203CB     892            lcall ?Send_Constant_String
0A6E D0E0       892            pop acc
0A70 D082       892            pop dpl
0A72 D083       892            pop dph
0A74 C0E0       893            push acc
0A76 7401       893            mov a, #1
0A78 14         893            dec a
0A79 1203D6     893            lcall ?Set_Cursor_2 ; Select column and row
0A7C D0E0       893            pop acc
0A7E C083       894            push dph
0A80 C082       894            push dpl
0A82 C0E0       894            push acc
0A84 90003F     894            mov dptr, #Line2
0A87 1203CB     894            lcall ?Send_Constant_String
0A8A D0E0       894            pop acc
0A8C D082       894            pop dpl
0A8E D083       894            pop dph
0A90            895   
0A90            896   FSM1_state5_done:
0A90 0208BD     897            ljmp FSM1
0A93            898   
0A93            899   
0A93            900            
0A93            901   EN
